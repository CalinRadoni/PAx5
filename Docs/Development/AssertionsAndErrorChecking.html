<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	</head>
	<body>
		<h1 id="Assertionsanderrorchecking">Assertions and error checking</h1>
		<h2 id="TheLogger">The Logger</h2>
		<h2 id="MainBoardLogger">MainBoard_Logger</h2>
		<p>The ASSERT macro is defined in 
			<em>MainBoard_Logger.h</em> as:
		</p>
		<pre><code>#define ASSERT(expr) \
    if (expr) \
        {} \
    else \
        assertionFailed(FileID, __LINE__)
</code></pre>
		<p>Also, in the 
			<em>MainBoard_Logger.h</em> file, a macro is defined to ensure that any file can call ASSERT with a unique file ID.
			<br/>The definition is:
		</p>
		<pre><code>#define FILEID(id) \
	const uint8_t FileID = id; \
    void AssertFileID##id(void) {}
</code></pre>
		<p>
			<strong>FileID</strong> is used by 
			<strong>ASSERT</strong> when calling the 
			<strong>assertionFailed</strong> function.
			<br/>The 
			<strong>AssertFileID##id</strong> function ensure that each file will have a unique ID. If two files are using the same ID the linker will generate an error.
		</p>
		<p>The definition of the 
			<em>assertionFailed</em> function, located in 
			<em>MainBoard_Logger.cpp</em> is:
		</p>
		<pre><code>void assertionFailed(const uint8_t FileID, uint16_t assertLine)
{
	hwLogger.AddEntry(FileID, 0, assertLine);
}
</code></pre>
		<p>so every failed assertion will record an event with code 0.</p>
		<h2 id="Generic.cppsourcefiles">Generic .cpp source files</h2>
		<p>To use the 
			<strong>ASSERT</strong> macro or 
			<strong>PAx5::hwLogger</strong> define the file ID at the top of  
			<em>.cpp</em> file and the specific log codes, if any.
		</p>
		<pre><code>FILEID(unique_8bit_ID)
#define LOG_CODE_onething     1 // data = ...
#define LOG_CODE_anotherthing 2 // data = ...
</code></pre>
		<p>To use 
			<strong>ASSERT</strong> just call it.
			<br/>To use 
			<strong>hwLogger</strong> call it like 
			<code>hwLogger.AddEntry(FileID, LOG_CODE_..., specific_16bit_data);</code>
		</p>
		<h3 id="References">References</h3>
		<p>The 
			<strong>ASSERT</strong> macro and unique file ID usage was adapted from:  
			<br/>
			<a href="http://barrgroup.com/Embedded-Systems/How-To/Define-Assert-Macro">How to Define Your Own assert() Macro for Embedded Systems</a>
		</p>
		<h2 id="Logcodes">Log codes</h2>
		<h3 id="FileID1MainBoard">FileID = 1 MainBoard</h3>
		<p>
			<strong>1</strong> LOG_CODE_START, 
			<code>data = (uint16_T)(RCC-&gt;CSR &gt;&gt; 24)</code>
			<br/>
			<strong>2</strong> LOG_CODE_CLOCK, data:
		</p>
		<ul>
			<li>1 = HSI timeout</li>
			<li>2 = PLL timeout</li>
			<li>3 = clock switching on PLL timeout</li>
		</ul>
		<h3 id="FileID5cpuSPI1">FileID = 5 cpu_SPI1</h3>
		<p>
			<strong>1</strong> LOG_CODE_SCW, transmission failed in SendCommandAndWait function, 
			<code>data = (cmd &lt;&lt; 8 | spiSlave)</code>
			<br/>
			<strong>2</strong> LOG_CODE_SCPW, transmission failed in SendCmdPlusAndWait function, 
			<code>data = (cmd &lt;&lt; 8 | spiSlave)</code>
			<br/>
			<strong>3</strong> LOG_CODE_SBW, transmission failed in SendBufferAndWait function, 
			<code>data = spiSlave</code>
			<br/>
			<strong>4</strong> LOG_CODE_IntHandler, unhandled interrupt case, 
			<code>data = ((DMA1-&gt;ISR &gt;&gt; 4) &lt;&lt; 8 | spiSlave)</code>
		</p>
		<h3 id="FileID6cpuI2C">FileID = 6 cpu_I2C</h3>
		<p>
			<strong>1</strong> LOG_CODE_RTimeout, read timeout, 
			<code>data = slaveAddress</code>
			<br/>
			<strong>2</strong> LOG_CODE_WTimeout, write timeout, 
			<code>data = slaveAddress</code>
			<br/>
			<strong>3</strong> LOG_CODE_IntHandler, unhandled interrupt case, 
			<code>data = (uint16_t)(I2C1-&gt;ISR)</code> at the entry of the interrupt handler
		</p>
		<h3 id="FileID7cpuUSART1">FileID = 7 cpu_USART1</h3>
		<p>
			<strong>1</strong> LOG_CODE_CfgTimeout, configuration failed, data unused
			<br/>
			<strong>2</strong> LOG_CODE_UB_Overflow, overflow detected, data unused
			<br/>
			<strong>3</strong> LOG_CODE_IntHandler, unhandled interrupt case, 
			<code>data = (uint16_t)USART1-&gt;ISR</code>
		</p>
		<h3 id="FileID8cpuMemoryEEPROM">FileID = 8 cpu_MemoryEEPROM</h3>
		<p>
			<strong>1</strong> LOG_CODE_Unlock, failed to unlock EEPROM, data unused
			<br/>
			<strong>2</strong> LOG_CODE_WriteUA, write error, 
			<code>data = userAddress</code>
			<br/>
			<strong>3</strong> LOG_CODE_WriteSR, recorded after LOG_CODE_WriteUA, 
			<code>data = (uint16_t)(FLASH-&gt;SR &gt;&gt; 2)</code>
		</p>
		<h3 id="FileID9cpuMemoryFLASH">FileID = 9 cpu_MemoryFLASH</h3>
		<p>
			<strong>1</strong> LOG_CODE_Unlock, failed to unlock FLASH, data:
		</p>
		<ul>
			<li>1 = EEPROM unlock failed</li>
			<li>2 = FLASH unlock failed</li>
			<li>3 = Option bytes unlock failed</li>
		</ul>
		<p>
			<strong>2</strong> LOG_CODE_EraseUA, page erase failed, 
			<code>data = page address</code>
			<br/>
			<strong>3</strong> LOG_CODE_EraseSR, recorded after LOG_CODE_EraseUA, 
			<code>data = (uint16_t)(FLASH-&gt;SR &gt;&gt; 2)</code>
			<br/>
			<strong>4</strong> LOG_CODE_WriteUA, half-page write failed, 
			<code>data = half-page address</code>
			<br/>
			<strong>5</strong> LOG_CODE_WriteSR, recorded after LOG_CODE_WriteUA, 
			<code>data = (uint16_t)(FLASH-&gt;SR &gt;&gt; 2)</code>
		</p>
	</body>
</html>